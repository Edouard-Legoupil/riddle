# WARNING - Generated by {fusen} from dev/ridlle_dev.Rmd: do not edit by hand

#' 
#' Work with RIDL resources (files)
#' 
#' @name resource
#'
#' @details You must have the necessary permissions to create, edit, or delete 
#'          datasets and their resources.
#'
#' Note that several fields are required for `resource_update()`, `resource_create()` and 
#' `resource_update()` operations to succeed. 
#' Consult \code{\link{resource_metadata()}} for the details.
#'
#' `resource_update()` will check if the resource exists in the dataset. 
#' If the resource name does not exist in the dataset, `resource_update()` will 
#' create a new resource. If the resource name already exists in the dataset, 
#' `resource_update()` will upload the resource and also increase the number 
#' in the version.
#'  
#'
#' For `resource_update()`/`resource_patch()` operations, it is recommended to 
#' call `resource_show()`, make the desired changes to the result, and then 
#' call `resource_update()`/`resource_patch()` with it.
#'
#' The difference between the update and patch methods is that the patch will 
#' perform an update of the provided parameters, while leaving all other 
#' parameters unchanged, whereas the update methods deletes all parameters
#'  not explicitly provided in the `metadata`.
#'
#' @param res_metadata Metadata created by \code{\link{resource_metadata()}}.
#' @param id The id or name of the resource.
#' @param package_id The id or name of the dataset to which this resource belongs to.
#' 
#' @importFrom httr upload_file

#' @rdname resource
#' @return metadata resource.
#' @export
#' @examples
#' # ## Full example available with the fetch function..
#' #-----
#' # ## Test search in prod
#' # Sys.unsetenv("USE_UAT")
#' # p <-  dataset_search("rms_v4")
#' # p
#' # list_of_resources <- p[["resources"]][[1]]
#' # knitr::kable(list_of_resources)
#'
#' #-----
#' # ## Test search in uat
#' # Sys.setenv(USE_UAT=1)
#' # p <-  dataset_search("tests")
#' # p
#' # ##take the first one
#' # ridlid <- as.character(p[9, c("id")])
#'
#' #-----
#' # ## Test resource in UAT
#' # Sys.setenv(USE_UAT=1)
#' # m <- riddle::dataset_metadata(title = "Testing Riddle Interface",
#' #                       name = "riddleapitest",
#' #                       notes = "Making an API test",
#' #                       owner_org = "americas",  ## be careful- all lower case!!!
#' #                       visibility = "public",
#' #                       geographies = "UNSPECIFIED",
#' #                       external_access_level = "open_access",
#' #                       data_collector = "myself",
#' #                       keywords = keywords[c("Environment", "Other")],
#' #                       unit_of_measurement = "byte",
#' #                       data_collection_technique = "oth",
#' #                       archived = "False")
#' # ## For the above to work - you need to make sure you have at least editor access
#' # ## to the corresponding container - i.e. owner_org = "exercise-container"
#' # p <- dataset_create(metadata = m)
#' # p <-  dataset_show('riddleapitest')
#' # ## Now testing adding the file "resource.R" as an attachment
#' # new_attachment <- riddle::resource_metadata(type = "attachment",
#' #                        url = "resourceR", 
#' #  upload = httr::upload_file(here::here("R","resource.R") ),
#' #                         name = "Rscript",
#' #                        format = "R",
#' #                        file_type = "report",
#' #                        version = "1",
#' #                        visibility = "public" )
#'  
#' # r <- resource_create(package_id = p$id,  res_metadata = new_attachment )
#' # resource_create(package_id = p$name,  res_metadata = new_attachment )
#' # ## Like before, the return value is a tibble representation of the resource.
#' # r
#'
#' # ## Another example with a data ressource
#' # m <- riddle::resource_metadata(type = "data",
#' #                        url = "mtcars.csv",
#' #   upload = httr::upload_file(system.file("extdata/mtcars.csv", package = "readr")),         
#' #                        name = "mtcars.csv",
#' #                        format = "csv",
#' #                        file_type = "microdata",
#' #                        date_range_start = "1973-01-01",
#' #                        date_range_end = "1973-12-31",
#' #                        version = "1",
#' #                        visibility = "public",
#' #                        process_status = "raw",
#' #                        identifiability = "anonymized_public")
#' # r <- resource_create(package_id = p$id, 
#' #                          res_metadata = m )
#' # ## let's get again the details of the dataset we want to add the resource in..
#' # r 
#'  
#' # ## and now can search for it - checking it is correctly there... 
#' #  resource_search("name:mtcarsriddle")
#'
#' # ## And once we’re done experimenting with the API, we should take down our
#' # ## toy dataset since we don’t really need it on RIDL.
#' # dataset_delete(p$id)
#'
#' # The return value is a representation of the dataset we just created in
#' # RIDL that you could inspect like any other R object.
#' # p
#' ## Now deleting this!
#' # dataset_delete(id = p$id)
#'
#'
resource_create <- function(package_id, res_metadata) {
  ## enc needs to be adjusted to multipart in case a file is uploaded...
  enc <- if(is.null(res_metadata$upload)) "json" else "multipart"
  
  r <- ridl(action ="resource_create", 
       package_id = package_id,
       !!!res_metadata,
       .encoding = enc) 
  
  res <- r$result %>% 
           resource_tibblify()  
  
  return(res)
  
}


#' @rdname search
#' @return tibble with list of related resource.
#' @export
resource_search <- function(query = NULL,
                            rows = NULL, 
                            start = NULL) {
  
    r <- ridl(action ="resource_search",
          !!!(as.list(match.call()[-1])))  
    
    res <- r$results %>% 
          tibble::as_tibble()  
  
  return(res)
}
  


#' @rdname resource
#' @return updated metadata resource.
#' @export
resource_update <- function(id, res_metadata) {
  enc <- if(is.null(res_metadata$upload)) "json" else "multipart"
  
  r <- ridl(action ="resource_update",
            id = id,
            !!!res_metadata,
            .encoding = enc) 
  
   res <-  r$result %>% 
           resource_tibblify()
  
  return(res)
}

#' @rdname resource
#' @return upload metadata resource.
#' @importFrom dplyr select
#' @export
resource_upload <- function(package_id, res_metadata) {
  
  resources_in_dataset <- dataset_show(package_id) |> 
    dplyr::select(resources)
  
  if(m$name %in% resources_in_dataset[[1]][[1]][["name"]]) {
    
    # Increase version in Metadata
    res_metadata$version <-
      as.character(as.numeric(resources_in_dataset$resources[[1]][resources_in_dataset$resources[[1]]["name"] == res_metadata$name, c("version")][[1]]) + 1L)
    
    enc <- if(is.null(res_metadata$upload)) "json" else "multipart"
    
    r <-  ridl(action ="resource_update",
         id = resources_in_dataset$resources[[1]][resources_in_dataset$resources[[1]]["name"] == res_metadata$name, c("id")][[1]],  # find the resource ID
         !!!res_metadata,
         .encoding = enc) 
    
    res <- r$result %>% 
           resource_tibblify()
    
    return(res)
    
  } else {
    ## enc needs to be adjusted to multipart in case a file is uploaded...
    enc <- if(is.null(res_metadata$upload)) "json" else "multipart"
    
    r <- ridl(action ="resource_create", 
         package_id = package_id,
         !!!res_metadata,
         .encoding = enc)
    
    res <- r$result %>% 
          resource_tibblify()
    
    return(res)
  }
  
}


#' @rdname resource
#' @export
resource_patch <- function(id, res_metadata) {
  
  enc <- if(is.null(res_metadata$upload)) "json" else "multipart"
  
  r <- ridl(action ="resource_patch",
            id = id,
            !!!res_metadata, 
            .encoding = enc)
  
   res <-  r$result %>% 
           resource_tibblify() 
  
  return(res)
}

#' @rdname resource
#' @export
resource_delete <- function(id) { 
  
  r <- ridl(action ="resource_delete",
       id = id)  
  
  return( cat("Resource deleted"))}


